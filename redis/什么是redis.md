抄写自：

**范蠡(li,第三声)** https://cloud.tencent.com/developer/article/1595230

**何轩** https://zhuanlan.zhihu.com/p/86396877

目的：自己背诵，掌握Redis

# 什么是redis？
redis是一个内存中的数据结构存储系统，可以用作数据库,缓存和消息队列中间件。Redis是C语言开发的一个开源的高性能键值对的内存数据库，可以用作数据库，缓存，消息中间件
等等。
它是一种NoSQL非关系型数据库
redis 作为一个内存数据库，有以下有点：
* 性能优秀，数据存在内存中，读写速度非常快，支持并发10wQPS
* 单进程单线程，是线程安全的，采用IO多路复用机制
* 丰富的数据类型，支持： 字符串，散列，列表，集合，有序集合等
* 支持数据持久化，可以将内存数据保存在磁盘中，重启时加载
* 主从复制，哨兵，高可用
* 可以用作分布式锁
* 可以作为消息中间件，支持发布订阅

## 5种数据类型
在抄之前，有必要先来了解一下Redis内部内存管理是如何描述这5种数据类型的
![image.png](https://upload-images.jianshu.io/upload_images/21849446-466ab934e713a36e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

首先，Redis内部使用一个RedisObject对象来表示所有的key和value
RedisObject 最主要的信息如上图所示：type表示一个value对象具体是何种数据类型，encoding是不同数据类型在Redis内部的存储方式
比如：type = string baioshi value 存储的是一个普通字符串，那么encoding可以是raw 或者 int


* 字符串 string

string 是redis最基本的类型，可以理解成与Memcached一模一样的类型，一个Key对应一个value。value不仅是String,也可以是数字
string 类型是二进制安全的，意思是Redis的string类型可以包含任何数据，比如jpg图片或者序列化的对象，string类型的值最大能存储512M

* 散列 hash

Hash是一个键值（key-value）的集合，Redis的Hash是一个string的key和value的映射表，Hash特别适合存储对象，常用命令：hget，hset，hgetall等

* 列表 list

List列表是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部或者尾部;
常用的命令：lpush, rpush, lpop, rpop, lrange(获取列表片段)
应用场景：List应用场景非常多，惹事Redis最重要的数据结构之一，比如说，B站的关注列表，粉丝列表都可以用List来实现
数据结构：List就是链表，可以用来当消息队列用，Redis提供了List的Push和Pop操作，还提供了操作某一段的API，可以直接查询或者删除某一段的元素。
实现方式：Redis List的实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。

* 集合 set

Set 是String类型的无序集合，集合是通过hashtable实现的，Set中的元素没有顺序的，而且是没有重复的，常用命令：sadd，spop， smembers, sunion(并集)，sinter(交集)， sdiff(差集)
应用场景：Redis Set对外提供的功能和list一样是一个列表，特殊之处在于Set是自动去重的，而且Set提供了判断某个成员是否在一个Set集合中。

* 有序集合 sorted sets

zest 和 set一样是string类型元素的集合，而且不允许重复的元素。常用命令：zadd， zrange，zrem， zcard等
使用场景：sorted set 可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，（自动排序）
当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set结构
和set相比，sorted set关联了一个double类型权重的参数score，使得集合中的元素能够按照score进行有序排列，Redis正式通过分数来为集合中的成员进行从大到小的排序

实现方式： Redis sorted set 的内部使用HashMap和跳跃表来保证数据的存储和有序，HashMap里放的是成员到score的映射
而跳跃表里存放的是所有的成员，排序依据是HashMap里存放的score，使用跳跃表的结构可以获得比较高的查询效率，并且在实现上比较简单

**数据类型应用场景**

| 类型  |   简介    |   特性    |   场景    |
|---|---|---|---|
|   string  |   -    |   可以包含任何数据，比如jpg图片或者序列化对象 |   -   |
|   hash    |   键值对集合，即编程语言中的map类型   |   适合存储对象，并且可以像数据库中的update属性一样只修改某一项的属性值    |   存储，读取，修改用户属性    |
|   list    |   链表（双向链表）    |   增删快，提供了操作某一元素的api |   最新消息排行；消息队列  |
|   set     |   hash表实现，元素不重复  |   添加，删除，查找的复杂度都是O(1)，提供了求交集，并集，差集的操作    |   共同好友；利用唯一性，统计访问网站的所有IP  |
|   sorted set  |   将set中的元素增加一个权重参数score，元素按score有序排列     |   数据插入集合的时候，已经天然排序好了    |   排行榜；带权重的消息队列    |

## 你是怎么用的？

* 平时就是有这几种方法：直接调用redis提供的函数；自己将官方提供的函数进行封装，在自己的框架结构里面使用
**重点介绍自己封装的：列表缓存**
***./lib/index.js***

## Redis的几种情况场景

### Redis雪崩
一般的热点数据或者用户操作频繁的数据都会做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存；

#### 定时任务刷新的弊端：
举个列子：如果热点数据的key过期时间都是设置了12小时，中午12点刷新的数据，0点有个活动这时，大量的用户涌入，假设每秒有6000个请求，本来可以抗住每秒5K个请求的，但是缓存中所有的key都失效了。
此时，这6k的请求都落在了数据库上，数据库肯定扛不住，真实情况就是数据库直挂了。即便重启数据库，数据库又立马被新流量打死了。
这种情况下，有Redis和没有Redis都一样，如果挂的是一个用户服务库，这种情况下基本上依赖他的服务会全部宕机。

#### 如何应对这种情况：
处理缓存雪崩的时候，在批量往Redis存入数据的时候，把每个key的过期时间都加个随机值，可以保证数据不会同一时间大面积失效。
```
setRedis(key, value, time+Math.random() * 1000)

```
如果Redis是集群部署，将热点数据均匀分布在不同的Redis库也能避免全部失效。
或者，设置热点数据过期时间为永久，如果有更新操作就更新缓存，这样比较保险。

> 常见的缓存更新策略
* 1.先删缓存，再更新数据库：又分为 `write-through` 和 `write-behind` ;个人记忆：直写缓存 和 后写缓存；直写缓存是先更新缓存本身，然后再去更新数据库；后写缓存是先更新 缓存本身，**过段时间(可以设置)**
再去更新数据库
* 2.先更新数据库，再删缓存
* 3.read/write through
* 4.异步写回。更新数据的时候，只更新缓存，不更新数据库，我们的缓存会异步批量的更新回数据库

策略1：并发操作情况下，一个操作更新，另外一个操作查询，更新操作删除缓存后还没来得及更新数据库，此时另外一个用户发起了查询操作，这个用户因没有命中缓存进而从数据库读，此时第一个操作还没到更新
数据库的阶段，读取到的是老数据，接着写到了缓存中，从而导致缓存中的数据变成脏数据，并且会一直脏下去直到缓存过期或者发起新的更新操作。

策略3：
这个套路就是更新数据库(Repostitory)的操作由缓存自己代理了。对于应用层面来讲，可以理解为：应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。

![read/write through.png](https://upload-images.jianshu.io/upload_images/21849446-daad8627f4aca69e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




### Redis击穿
* 缓存穿透 和 缓存击穿的区别，和雪崩又有什么不同
#### 缓存穿透
而缓存穿透 是 缓存和数据库中都没有的数据，而用户不断的发起请求。比如说，我数据库的Id都是从0自增的，如果发起 id = -1 的数据或者 id 特别大，大到不存在的数据的数据，这样的请求不间断的攻击导致数据库压力很大，
数据库直接被击垮了。

这个时候就需要一个东西来做过滤了，过滤掉不存在的id，或者不存在的key；布隆过滤器，可以很好的预防缓存穿透的发生。

##### 那什么是布隆过滤器呢？他的原理是什么？
先说几个自己用的产品构想： 
* B站的视频，为什么你刷到的都是你还没看到过的，而你看到的那些都不会给你推荐
* 还有google中的垃圾邮箱过滤是如何实现的？
* 比如，在某些文档处理中，可以知道你的单词是否拼写错误？
* 自己做爬虫的时候，已经爬过的不想再爬第二遍


***完成以上的功能，我们要从哪些角度来考虑问题*** ？
1. 考虑数据结构：比如 数组？ 链表？ 树（平衡二叉树）？红黑树？还是哈希表？
2. 常见的排序又有哪些？二分搜索是否可以快速高效的处理大部分数据？
3. 小打小闹也不错，用数据链表啊这些的，可以，但是，当你的某些数据达到了比如说 4kw呢，你的内存够不够大！如果说hash表的效率很高，查询的效率可以达到O(1)，但hash表消耗的内存依然很高，
比如说，使用hash表存储1亿个email的消耗，hash表的做法：首先，hash函数将一个email地址映射为8Byte信息指纹；考虑到hash冲突，存储效率通常小于50%；因此消耗的内存：8*2*1亿=1.6G内存。

布尔过滤器的原理：



